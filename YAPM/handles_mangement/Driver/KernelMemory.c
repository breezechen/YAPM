/*

  KernelMemory.C

  Author: <your name>
  Last Updated: 2002-12-27

  This framework is generated by QuickSYS 0.2.2

*/

#include <ntddk.h>

#if DBG
#define dprintf DbgPrint
#else
#define dprintf
#endif

#define kprintf DbgPrint

#define NT_DEVICE_NAME	L"\\Device\\KernelMemory"
#define DOS_DEVICE_NAME L"\\DosDevices\\KernelMemory"

#include "KernelMemory.h"

NTSTATUS
KernelmemoryDispatchCreate(
	IN PDEVICE_OBJECT DeviceObject,
	IN PIRP Irp
	);

NTSTATUS
KernelmemoryDispatchClose(
	IN PDEVICE_OBJECT DeviceObject,
	IN PIRP Irp
	);

NTSTATUS
KernelmemoryDispatchDeviceControl(
	IN PDEVICE_OBJECT DeviceObject,
	IN PIRP Irp
	);

VOID
KernelmemoryUnload(
	IN PDRIVER_OBJECT DriverObject
	);

NTSTATUS
DriverEntry(
	IN PDRIVER_OBJECT DriverObject,
	IN PUNICODE_STRING RegistryPath
	)
{
	NTSTATUS ntStatus;
    PDEVICE_OBJECT DeviceObject = NULL;
    UNICODE_STRING ntDeviceName, dosDeviceName;
    PDEVICE_EXTENSION DeviceExtension;
	BOOLEAN	fSymbolicLink = FALSE;

    dprintf("[KernelMemory] DriverEntry: %S\n", RegistryPath->Buffer);

    //
    // A real driver would:
    //
    //     1. Report it's resources (IoReportResourceUsage)
    //
    //     2. Attempt to locate the device(s) it supports

    //
    // OK, we've claimed our resources & found our h/w, so create
    // a device and initialize stuff...
    //

    RtlInitUnicodeString(&ntDeviceName, NT_DEVICE_NAME);

    //
    // Create an EXCLUSIVE device, i.e. only 1 thread at a time can send
    // i/o requests.
    //

    ntStatus = IoCreateDevice(
		DriverObject,
		sizeof(DEVICE_EXTENSION), // DeviceExtensionSize
		&ntDeviceName, // DeviceName
		FILE_DEVICE_KERNELMEMORY, // DeviceType
		0, // DeviceCharacteristics
		TRUE, // Exclusive
		&DeviceObject // [OUT]
		);

    if (!NT_SUCCESS(ntStatus))
	{
		dprintf("[KernelMemory] IoCreateDevice=0x%x\n", ntStatus);
		goto __failed;
	}

	DeviceExtension = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;

	//
	// Set up synchronization objects, state info,, etc.
	//

    //
    // Create a symbolic link that Win32 apps can specify to gain access
    // to this driver/device
    //

    RtlInitUnicodeString(&dosDeviceName, DOS_DEVICE_NAME);

    ntStatus = IoCreateSymbolicLink(&dosDeviceName, &ntDeviceName);

    if (!NT_SUCCESS(ntStatus))
    {
        dprintf("[KernelMemory] IoCreateSymbolicLink=0x%x\n", ntStatus);
		goto __failed;
    }

	fSymbolicLink = TRUE;

    //
    // Create dispatch points for device control, create, close.
    //

    DriverObject->MajorFunction[IRP_MJ_CREATE]         = KernelmemoryDispatchCreate;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]          = KernelmemoryDispatchClose;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = KernelmemoryDispatchDeviceControl;
    DriverObject->DriverUnload                         = KernelmemoryUnload;

    if (!NT_SUCCESS(ntStatus))
		goto __failed;

    return ntStatus;

__failed:

	if (fSymbolicLink)
		IoDeleteSymbolicLink(&dosDeviceName);

	if (DeviceObject)
		IoDeleteDevice(DeviceObject);

	return ntStatus;
}

NTSTATUS
KernelmemoryDispatchCreate(
	IN PDEVICE_OBJECT DeviceObject,
	IN PIRP Irp
	)
{
	NTSTATUS ntStatus;

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

	dprintf("[KernelMemory] IRP_MJ_CREATE\n");

    ntStatus = Irp->IoStatus.Status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return ntStatus;
}

NTSTATUS
KernelmemoryDispatchClose(
	IN PDEVICE_OBJECT DeviceObject,
	IN PIRP Irp
	)
{
	NTSTATUS ntStatus;

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

	dprintf("[KernelMemory] IRP_MJ_CLOSE\n");

    ntStatus = Irp->IoStatus.Status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return ntStatus;
}

IrpCompletionRoutine(
        PDEVICE_OBJECT          pDeviceObject,
        PIRP                            pIrp,
        PVOID                           pContext)
{
    if (pIrp->UserIosb)
        *pIrp->UserIosb = pIrp->IoStatus;
    if (pIrp->UserEvent)
        KeSetEvent(pIrp->UserEvent, 0, FALSE);
    IoFreeIrp(pIrp);
    return STATUS_MORE_PROCESSING_REQUIRED;
}

//renvoie le nom du fichier dont l'objet est spécifié
//===================================================
//lpObject : objet dont le nom est à trouver (objet de fichier)
//lpBuffer : pointeur vers une zone de mémoire dans laquelle stocker le nom du fichier
//cette zone contient dans le premier DWORD : la taille (en octet) de la chaine qui suit
//nBufferLength : taille de cette zone de mémoire
//lpReturnLength : taille des données inscrites dans la zone de mémoire
NTSTATUS
GetObjectName(
	IN PFILE_OBJECT lpObject,
	IN OUT LPVOID lpBuffer,
	IN ULONG nBufferLength,
	OUT PULONG lpReturnLength
	)
{
	//taille du nom de l'objet
	ULONG nObjectName=0;
	//pointeur vers l'objet parent de l'objet courant
	PFILE_OBJECT lpRelated;
	//pointeur vers la zone de mémoire passée en argument
	LPVOID lpName = lpBuffer;
	//pointeur vers le premier DWORD de la zone mémoire passée en argument
	//c'est la taille de la chaine qui suit dans la zone mémoire
	ULONG* lpLength = lpBuffer;

	//si le pointeur vers le périphérique d'attachement au système de fichier (lecteur) n'est pas nul
	if (lpObject->DeviceObject)
	{
		//on demande sont nom : correspond au nom interne du lecteur
		ObQueryNameString((LPVOID)lpObject->DeviceObject,lpName,nBufferLength,lpReturnLength);
		//on incrémente le pointeur de chaine jusqu'à la fin du nom de lecteur (avant les NULLs)
		(LPCHAR)lpName += *lpReturnLength-2;
		//décrémente la taille disponible dans la zone mémoire
		nBufferLength -= *lpReturnLength-2;
	}
	//si pointeur invalide
	else
	{
		//incrémentation pour passer le premier DWORD de taille
		(LPCHAR)lpName = (LPCHAR)lpName + 4;
		//décrémentation de lka place disponible
		nBufferLength -= 4;
	}
	
	//si le nom d'objet est absent
	if (!lpObject->FileName.Buffer)
		//on renvoie simplement le nom de lecteur
		return STATUS_SUCCESS;

	//pour le calcul de la taille du nom complet de l'objet
	//on parcourt les objets parent jusqu'à épuisement de la parenté
	//premier objet parent
	lpRelated = lpObject;
	do
	{
		// on ajoute la taille du nom du parent à la taille requise
		nObjectName += lpRelated->FileName.Length;
		// on descend d'un parent : le parent du parent
		lpRelated = lpRelated->RelatedFileObject;
	}
	//tant qu'il existe encore un parent
	while (lpRelated);
	
	// on calcule la taille requise
	*lpReturnLength += nObjectName;
	//on la met dans le début de la zone mémoire
	*lpLength = *lpReturnLength;

	//si on n'a pas la place dans la zone mémoire
	if (nObjectName > nBufferLength)
	{	
		//zone mémoire trop petite
		return STATUS_BUFFER_TOO_SMALL;
	}

	//sinon incrémentation du pointeur de chaine à la fin de la chaine
	//en effet le nom de l'objet passé en argument se trouve à la fin de la chaine
	//son parent encore avant et ainsi de suite
	//il faut donc ajouter à la chaine par la fin
	(LPCHAR)lpName += nObjectName;
	//on termine par un NULL UNICODE
	*(unsigned short*)lpName = 0;

	//on repart du début de l'objet passé en argument (le fils)
	lpRelated = lpObject;
	do
	{
		//on se place au début de l'emplacement prévu pour le nom de ce parent
		(LPCHAR)lpName -= lpRelated->FileName.Length;
		//on copie la chaine de nom du parent à l'emplacement prévu
		RtlCopyMemory(lpName,lpRelated->FileName.Buffer,lpRelated->FileName.Length);

		//parent précédent ce parent : le parent du parent
		lpRelated = lpRelated->RelatedFileObject;
	}
	//tant qu'on trouve encore un parent
	while (lpRelated);
	
	//debug
	dprintf("%ws",(WCHAR*)lpBuffer);

	//succès
	return STATUS_SUCCESS;
}

NTSTATUS
KernelmemoryDispatchDeviceControl(
	IN PDEVICE_OBJECT DeviceObject,
	IN PIRP Irp
	)
{
	//status de la requête
	NTSTATUS ntStatus;
	//emplacement de pile de requête pour notre pilote
    PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(Irp);
	//extension de notre pilote
    PDEVICE_EXTENSION DeviceExtension = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;
	//buffer d'entrée pour une requête
    SYSTEM_HANDLE_INFORMATION InBufferHandle;
	//buffer d'entrée pour une autre requête
	GETKERNELMEMORY InBuffer;
	//pointeur vers le buffer d'entrée sortie de requête
	LPVOID lpOutBuffer;
	//taille des buffers, code de requête
    ULONG nInBufferSize, nOutBufferSize, dwIoControlCode;
	//pointeur vers un objet
	LPVOID lpObject;
	//handles
	HANDLE ph,dh;
	//atributs de l'objet
	OBJECT_ATTRIBUTES attr = {0};
	//PID du processus
	CLIENT_ID pid;

	//init
    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    //
    // Get the pointer to the input/output buffer and it's length
    //

    lpOutBuffer = Irp->AssociatedIrp.SystemBuffer;
    nInBufferSize = IrpStack->Parameters.DeviceIoControl.InputBufferLength;
    nOutBufferSize = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;

    dprintf("[KernelMemory] IRP_MJ_DEVICE_CONTROL\n");

    dwIoControlCode = IrpStack->Parameters.DeviceIoControl.IoControlCode;

    switch (dwIoControlCode)
    {
		//première requête : lire une zone mémoire kernel
	case IOCTL_KERNELMEMORY_GETKERNELMEMORY:
		{
			//si la taille du buffer d'entrée est inférieure à celle attendue :certainement erreur sur le contenu
			if (nInBufferSize < sizeof(GETKERNELMEMORY))
			{
				Irp->IoStatus.Status = STATUS_BUFFER_TOO_SMALL;
				break;
			}
			
			//sinon, on copie le buffer d'entrée dans une structure appropriée : information sur la zone mémoire kernel à lire
			InBuffer = *((LPGETKERNELMEMORY)Irp->AssociatedIrp.SystemBuffer);
			
			//si pas assez dans le buffer de sortie
			if (nOutBufferSize < (InBuffer.dwSize))
			{
				//erreur
				Irp->IoStatus.Status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			//traitement erreurs imprévues
			__try
			{
				//on copie la zone de mémoire
				RtlCopyMemory(lpOutBuffer,InBuffer.lpPointer,InBuffer.dwSize);
				//on indique la taille copiée
				Irp->IoStatus.Information = InBuffer.dwSize;
			}
			//exception
			__except (EXCEPTION_EXECUTE_HANDLER)
			{
				Irp->IoStatus.Status = STATUS_ACCESS_VIOLATION;
			}

            break;
		}
		//deuxième requête : obtenir le nom d'un handle (fichier de préférence)
	case IOCTL_KERNELMEMORY_GETOBJECTNAME:
		{
			//si la taille du buffer d'entrée est incorrecte
			if (nInBufferSize < sizeof(SYSTEM_HANDLE_INFORMATION))
			{
				//erreur
				Irp->IoStatus.Status = STATUS_BUFFER_TOO_SMALL;
				break;
			}
			
			//gestion des erreurs
			__try
			{
				//on copie le contenu du buffer d'entrée dans une structure adéquat : information sur un handle
				InBufferHandle = *(PSYSTEM_HANDLE_INFORMATION)(Irp->AssociatedIrp.SystemBuffer);

				//init de la taille de la structure pour ZwOpenProcess
				attr.Length = sizeof(OBJECT_ATTRIBUTES);
				pid.UniqueThread = 0;
				//pid du processus qui possède le handle
				pid.UniqueProcess = (HANDLE)InBufferHandle.ProcessID;
				//on ouvre un handle de processus
				ZwOpenProcess(&ph,0x40,&attr,&pid);

				//duplique le handle dans notre driver
				ZwDuplicateObject(ph,(HANDLE)InBufferHandle.Handle,(HANDLE)0xFFFFFFFF,&dh,0,0,2);
				//ferme le handle de processus
				ZwClose(ph);

				//demande un pointeur d'objet pour le handle dupliqué
				ObReferenceObjectByHandle(dh,0x80000000,0,0,&lpObject,0);

				//si l'objet (supposé fichier) est occupé ou attendu
				if (((PFILE_OBJECT)lpObject)->Busy || ((PFILE_OBJECT)lpObject)->Waiters)
				{					
					//on supprime notre référence à l'objet
					ObDereferenceObject(lpObject);
					//on ferme le handle
					ZwClose(dh);

					//debug
					dprintf("Busy : PID:%u Handle:%u Pointer:%u",InBufferHandle.ProcessID,InBufferHandle.Handle,InBufferHandle.Object);
				
					// on demande le nom de l'objet fichier
					Irp->IoStatus.Status = GetObjectName((PFILE_OBJECT)InBufferHandle.Object,lpOutBuffer,nOutBufferSize,&Irp->IoStatus.Information);

					// fin de la requête
					IoCompleteRequest(Irp, IO_NO_INCREMENT);
					return Irp->IoStatus.Status;
				}
				//sinon on demande le nom de l'objet par ObQueryNameString
				else
					Irp->IoStatus.Status = ObQueryNameString(lpObject,(POBJECT_NAME_INFORMATION)lpOutBuffer,nOutBufferSize,&Irp->IoStatus.Information);
			
				//on supprime notre référence à l'objet
				ObDereferenceObject(lpObject);
			
				//on ferme le handle dupliqué
				ZwClose(dh);
			}
			//traitement des exceptions
			__except (EXCEPTION_EXECUTE_HANDLER)
			{
				Irp->IoStatus.Status = STATUS_ACCESS_VIOLATION;
			}

			break;
		}
	//autres requêtes : erreur
    default:
        Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;

        dprintf("[KernelMemory] unknown IRP_MJ_DEVICE_CONTROL\n");

        break;
	}

    //
    // DON'T get cute and try to use the status field of
    // the irp in the return status.  That IRP IS GONE as
    // soon as you call IoCompleteRequest.
    //

    ntStatus = Irp->IoStatus.Status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    //
    // We never have pending operation so always return the status code.
    //

    return ntStatus;
}

VOID
KernelmemoryUnload(
	IN PDRIVER_OBJECT DriverObject
	)
{
    UNICODE_STRING dosDeviceName;

	//
    // Free any resources
    //

    //
    // Delete the symbolic link
    //

    RtlInitUnicodeString(&dosDeviceName, DOS_DEVICE_NAME);

    IoDeleteSymbolicLink(&dosDeviceName);

    //
    // Delete the device object
    //

    IoDeleteDevice(DriverObject->DeviceObject);

    dprintf("[KernelMemory] unloaded\n");
}

